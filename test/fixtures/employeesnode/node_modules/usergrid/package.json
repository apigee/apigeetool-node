{
  "name": "usergrid",
  "version": "0.10.7",
  "description": "A Node.js module for making API calls to App Services (Usergrid) from within Node.js",
  "main": "./lib/usergrid.js",
  "dependencies": {
    "request": "2.12.x"
  },
  "devDependencies": {
    "mocha": "1.7.x",
    "should": "1.2.1"
  },
  "scripts": {
    "test": "mocha",
    "start": "node example/server.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/apigee/usergrid-node-module.git"
  },
  "bugs": {
    "url": "http://github.com/apigee/usergrid-node-module.git/issues"
  },
  "keywords": [
    "Node",
    "Usergrid",
    "Apigee",
    "API"
  ],
  "tags": [
    "usergrid",
    "API",
    "Apigee"
  ],
  "author": {
    "name": "Rod Simpson",
    "email": "rod@rodsimpson.com",
    "url": "http://rodsimpson.com"
  },
  "license": "Apache 2.0",
  "readme": "##Version\n\nCurrent Version: **0.10.7**\n\nSee change log:\n\n<https://github.com/apigee/usergrid-node-module/blob/master/changelog.md>\n\n\n##Comments / Questions\nPlease feel free to send comments or questions:\n\n\ttwitter: @rockerston\n\temail: rod at apigee.com\n\nOr just open github issues.  I truly want to know what you think, and will address all suggestions / comments / concerns.\n\nThank you!\n\nRod\n\n\n##Overview\nThis Node.js module, which simplifies the process of making API calls to App Services from within Node.js, is provided by [Apigee](http://apigee.com) and is available as an open-source project on github.  We welcome your contributions and suggestions. The repository is located here:\n\n<https://github.com/apigee/usergrid-node-module>\n\nYou can download this package here:\n\n* Download as a zip file: <https://github.com/apigee/usergrid-node-module/archive/master.zip>\n* Download as a tar.gz file: <https://github.com/apigee/usergrid-node-module/archive/master.tar.gz>\n\n\nTo find out more about Apigee App Services, see:\n\n<http://apigee.com/about/developers>\n\nTo view the Apigee App Services documentation, see:\n\n<http://apigee.com/docs/app_services>\n\n\n##Client side Javascript\nWant to make calls to App Services (Usergrid) client-side? No problem - just head over to the Usergrid Javascript SDK:\n\n<https://github.com/apigee/usergrid-javascript-sdk>\n\nThe syntax for this Node module and the Javascript SDK are almost exactly the same so you can easily transition between them.\n\n\n##Installing\nUse npm:\n\n\t$ npm install usergrid\n\n\n##Getting started\nInclude the module:\n\n\tvar usergrid = require('usergrid');\n\nThen create a new client:\n\n\tvar client = new usergrid.client({\n\t\torgName:'yourorgname',\n\t\tappName:'sandbox',\n\t\tlogging: true, //optional - turn on logging, off by default\n\t});\n\nThe preceding example shows how to use the \"Sandbox\" testing app, which does not require any authentication.  The \"Sandbox\" comes with all new App Services accounts.\n\nIf you are ready to use authentication, then create your client this way:\n\n\tvar client = new usergrid.client({\n\t\torgName:'yourorgname',\n\t\tappName:'yourappname',\n\t\tauthType:usergrid.AUTH_CLIENT_ID,\n\t\tclientId:'<your client id>',\n\t\tclientSecret:'<your client secret>',\n\t\tlogging: false, //optional - turn on logging, off by default\n\t\tbuildCurl: false //optional - turn on curl commands, off by default\n\t});\n\nThe last two items are optional. The **logging** option will enable console.log output from the client.  The **buildCurl** option will cause cURL equivalent commands of all calls to the API to be displayed in the console.log output.\n\n**Note:** you can find your client secret and client id on the \"Properties\" page of the [Admin Portal](http://apigee.com/usergrid).\n\nYou are now ready to use the usergrid handle to make calls against the API.\n\n\n##About the samples\nAll of the samples provided in this readme file come from unit tests in the test.js which is located in the root of this project.\n\n\nTo run the test file, first do the following:\n\n1. Change the org-name and app-name to point to your Usergrid account.  Log into the [Admin Portal](http://apigee.com/usergrid) to see this information.\n2. Change the client secret and client id\n\nThen run the code:\n\n\t$ node test.js\n\nThe samples in this file will show you the many ways you can use this module.\n\n\n##Entities and Collections\nUsergrid stores its data as \"Entities\" in \"Collections\".  Entities are essentially JSON objects and Collections are just like folders for storing these objects. You can learn more about Entities and Collections in the App Services docs:\n\n<http://apigee.com/docs/usergrid/content/data-model>\n\n\n##Entities\nThis module provides an easy way to make new entities. Here is a simple example that shows how to create a new object of type \"dogs\":\n\n\tvar options = {\n\t\ttype:'dogs',\n\t\tname:'Dino'\n\t}\n\tclient.createEntity(options, function (err, dog) {\n\t\tif (err) {\n\t\t\t//error - dog not created\n\t\t} else {\n\t\t\t//success -dog is created\n\n\t\t\t//once the dog is created, you can set single properties:\n\t\t\tdog.set('breed','Dinosaur');\n\n\t\t\t//or a JSON object:\n\t\t\tvar data = {\n\t\t\t\tmaster:'Fred',\n\t\t\t\tstate:'hungry'\n\t\t\t}\n\t\t\t//set is additive, so previously set properties are not overwritten\n\t\t\tdog.set(data);\n\n\t\t\t//finally, call save on the object to save it back to the database\n\t\t\tdog.save(function(err){\n\t\t\t\tif (err){\n\t\t\t\t\t//error - dog not saved\n\t\t\t\t} else {\n\t\t\t\t\t//success - new dog is saved\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n**note:** all calls to the API will be executed asynchronously, so it is important that you use a callback.\n\n\nYou can also refresh the object from the database if needed (in case the data has been updated by a different client or device):\n\n\t//call fetch to refresh the data from the server\n\tdog.fetch(function(err){\n\t\tif (err){\n\t\t\t// error - dog not refreshed from database;\n\t\t} else {\n\t\t\t//dog has been refreshed from the database\n\t\t\t//will only work if the UUID for the entity is in the dog object\n\t\t\t//success - dog entity refreshed from database;\n\t\t}\n\t});\n\nTo remove the entity from the database:\n\n\t//the destroy method will delete the entity from the database\n\tdog.destroy(function(err){\n\t\tif (err){\n\t\t\t//error - dog not removed from database\n\t\t} else {\n\t\t\t//success - dog removed from database (no real dogs were harmed!)\n\t\t\tdog = null; //no real dogs were harmed!\n\t\t}\n\t});\n\nTo set properties on the entity, use the set() method:\n\n\t//once the dog is created, you can set single properties:\n\tdog.set('breed','Dinosaur');\n\n\t//or a JSON object:\n\tvar data = {\n\t\tmaster:'Fred',\n\t\tstate:'hungry'\n\t}\n\t//set is additive, so previously set properties are not overwritten\n\tdog.set(data);\n\n**Note:** These properties are now set locally, but make sure you call the .save() method on the entity to save them back to the database!\n\nTo get a single property from the entity, use the get method:\n\n\tvar breed = dog.get('breed');\n\nor\n\n\tvar state = dog.get('state');\n\nor, to get a JSON object with all properties, don't pass a key\n\n\tvar props = dog.get();\n\nBased on the set statements above, our JSON object should look like this:\n\n\t{\n\t\tname:'Dino',\n\t\ttype:'dogs',\n\t\tbreed:'Dinosaur',\n\t\tmaster:'Fred',\n\t\tstate:'hungry'\n\t}\n\n**Wait!** But what if my entity already exists on the server?\n\nDuring a client.createEntity call, there are two ways that you can choose to handle this situation.  The question is, what should the client do if an entity with the same name, username, or uuid already exists on the server?\n\n  \t1. Give you back an error.\n  \t2. Give you back the pre-existing entity.\n\nIf you want to get back an error when the entity already exists, then simply call the client.createEntity function as above. If there is a collision, you will get back a 400  However, if you want the existing entity to be returned, then set the getOnExist flag to true:\n\n\tvar options = {\n\t\ttype:'dogs',\n\t\tname:'Dino',\n\t\tgetOnExist:true\n\t}\n\tclient.createEntity(options, function (err, dog) {\n\t\tif (err) {\n\t\t\t//error - dog not created\n\t\t} else {\n\t\t\t//success -dog is created or returned, depending on if it already exists or not\n\n\nAlternatively, if you know that you only want to retrieve an existing entity, use the getEntity method:\n\n\tvar options = {\n\t\ttype:'users',\n\t\tusername:'marty'\n\t}\n\tclient.getEntity(options, function(err, existingUser){\n\t\tif (err){\n\t\t\t//error - existing user not retrieved\n\t\t} else {\n\t\t\t//success - existing user was retrieved\n\n\t\t\tvar username = existingUser.get('username');\n\t\t}\n\t});\n\n\n##The Collection object\nThe Collection object models Collections in the database.  Once you start programming your app, you will likely find that this is the most useful method of interacting with the database.  Creating a collection will automatically populate the object with entities from the collection. The following example shows how to create a Collection object, then how to use entities once the Collection has been populated with entities from the server:\n\n\t//options object needs to have the type (which is the collection type)\n\tvar options = {\n\t\ttype:'dogs',\n\t\tqs:{ql:'order by index'}\n\t}\n\n\tclient.createCollection(options, function (err, dogs) {\n\t\tif (err) {\n\t\t\t//error - could not make collection\n\t\t} else {\n\n\t\t\t//success - new Collection worked\n\n\t\t\t//we got the dogs, now display the Entities:\n\t\t\twhile(dogs.hasNextEntity()) {\n\t\t\t\t//get a reference to the dog\n\t\t\t\tdog = dogs.getNextEntity();\n\t\t\t\tvar name = dog.get('name');\n\t\t\t\tnotice('dog is called ' + name);\n\t\t\t}\n\n\t\t\t//success - looped through dogs\n\n\t\t}\n\t});\n\n\nYou can also add a new entity of the same type to the collection:\n\n\t//create a new dog and add it to the collection\n\tvar options = {\n\t\tname:'extra-dog',\n\t\tfur:'shedding'\n\t}\n\t//just pass the options to the addEntity method\n\t//to the collection and it is saved automatically\n\tdogs.addEntity(options, function(err, dog, data) {\n\t\tif (err) {\n\t\t\t//error - extra dog not saved or added to collection\n\t\t} else {\n\t\t\t//success - extra dog saved and added to collection\n\t\t}\n\t});\n\n\n##Collection iteration and paging\nThe Collection object works in Pages of data.  This means that at any given time, the Collection object will have one page of data loaded.  You can iterate across all the entities in the current page of data by using the following pattern:\n\n\t//we got the dogs, now display the Entities:\n\twhile(dogs.hasNextEntity()) {\n\t\t//get a reference to the dog\n\t\tdog = dogs.getNextEntity();\n\t\tvar name = dog.get('name');\n\t\tnotice('dog is called ' + name);\n\t}\n\nTo get the next page of data from the server, use the following pattern:\n\n\tif (dogs.hasNextPage()) {\n\t\t//there is a next page, so get it from the server\n\t\tdogs.getNextPage(function(err){\n\t\t\tif (err) {\n\t\t\t\t//error - could not get next page of dogs\n\t\t\t} else {\n\t\t\t\t//success - got next page of dogs\n\t\t\t\t//we got the dogs, now display the Entities:\n\t\t\t\twhile(dogs.hasNextEntity()) {\n\t\t\t\t\t//get a reference to the dog\n\t\t\t\t\tdog = dogs.getNextEntity();\n\t\t\t\t\tvar name = dog.get('name');\n\t\t\t\t\tnotice('dog is called ' + name);\n\t\t\t\t}\n\t\t\t\t//success - looped through dogs\n\t\t\t}\n\t\t});\n\t}\n\nYou can use the same pattern to get a previous page of data:\n\n\tif (dogs.hasPreviousPage()) {\n\t\t//there is a previous page, so get it from the server\n\t\tdogs.getPreviousPage(function(err){\n\t\t\tif(err) {\n\t\t\t\t//error - could not get previous page of dogs\n\t\t\t} else {\n\t\t\t\t//success - got next page of dogs\n\t\t\t\t//we got the dogs, now display the Entities:\n\t\t\t\twhile(dogs.hasNextEntity()) {\n\t\t\t\t\t//get a reference to the dog\n\t\t\t\t\tdog = dogs.getNextEntity();\n\t\t\t\t\tvar name = dog.get('name');\n\t\t\t\t\tnotice('dog is called ' + name);\n\t\t\t\t}\n\t\t\t\t//success - looped through dogs\n\t\t\t}\n\t\t});\n\t}\n\nBy default, the database will return 10 entities per page.  You can change that amount by setting a limit:\n\n\n\tvar options = {\n\t\ttype:'dogs',\n\t\tqs:{limit:50} //limit statement set to 50\n\t}\n\n\tclient.createCollection(options, function (err, dogs) {\n\t\tif (err) {\n\t\t\t//error - could not get all dogs\n\t\t} else {\n\t\t\t//success - got at most 50 dogs\n\t\t}\n\t}\n\nSeveral other convenience methods exist to make working with pages of data easier:\n\n* getFirstEntity - gets the first entity of a page\n* getLastEntity - gets the last entity of a page\n* resetEntityPointer - sets the internal pointer back to the first element of the page\n* getEntityByUUID - returns the entity if it is in the current page\n\n\n###Custom Queries\nA custom query allows you to tell the API that you want your results filtered or altered in some way.  To specify that the query results should be ordered by creation date, add the qs parameter to the options object:\n\n\tvar options = {\n\t\ttype:'dogs',\n\t\tqs:{ql:'order by created DESC'}\n\t};\n\nYou may find that you need to change the query on an existing object.  Simply access the qs property directly:\n\n\tdogs.qs = {ql:'order by created DESC'};\n\n\nIf you also wanted to get more entities in the result set than the default 10, say 100, you can specify a query similar to the following (the limit can be a maximum of 999):\n\n\tdogs.qs = {ql:'order by created DESC',limit:'100'};\n\n**Note**: there are many cases where expanding the result set is useful.  But be careful - the more results you get back in a single call, the longer it will take to transmit the data back to your app.\n\nAnother common requirement is to limit the results to a specific query.  For example, to get all brown dogs, use the following syntax:\n\n\tdogs.qs = {ql:\"select * where color='brown'\"};\n\nYou can also limit the results returned such that only the fields you specify are returned:\n\n\tdogs.qs = {'ql':\"select name, age where color='brown'\"};\n\n**Note:** in the two preceding examples that we put single quotes around 'brown', so it will be searched as a string.\n\nYou can find more information on custom queries here:\n\n<http://apigee.com/docs/usergrid/content/queries-and-parameters>\n\n\n##Modeling users with the Entity object\nThere is no specific User object in the module.  Instead, you simply need to use the Entity object, specifying a type of \"users\".  Here is an example:\n\n\t//type is 'users', set additional paramaters as needed\n\tvar options = {\n\t\ttype:'users',\n\t\tusername:'marty',\n\t\tpassword:'mysecurepassword',\n\t\tname:'Marty McFly',\n\t\tcity:'Hill Valley'\n\t}\n\n  \tclient.createEntity(options, function (err, marty) {\n\t\tif (err){\n\t\t\t//error - user not saved\n\t\t} else {\n\t\t\t//success - user saved\n\t\t}\n\t});\n\n\nIf the user is modified, just call save on the user again:\n\n\t//add properties cumulatively\n\tmarty.set('state', 'California');\n\tmarty.set(\"girlfriend\",\"Jennifer\");\n\tmarty.save(function(err){\n\t\tif (err){\n\t\t\t//error - user not updated\n\t\t} else {\n\t\t\t//success - user updated\n\t\t}\n\t});\n\nTo refresh the user's information in the database:\n\n\tmarty.fetch(function(err){\n\t\tif (err){\n\t\t\t//error - not refreshed\n\t\t} else {\n\t\t\t//success - user refreshed\n\t\t}\n\t});\n\nIf you no longer need the object, call the delete() method and the object will be deleted from database:\n\n\tmarty.destroy(function(err){\n\t\tif (err){\n\t\t\t//error - user not deleted from database\n\t\t} else {\n\t\t\t//success - user deleted from database\n\t\t\tmarty = null; //blow away the local object\n\t\t}\n\t});\n\n\n###Making connections\nConnections are a way to connect to entities with some verb.  This is called an entity relationship.  For example, if you have a user entity with username of marty, and a dog entity with a name of einstein, then using our RESTful API, you could make a call like this:\n\n\tPOST users/marty/likes/dogs/einstein\n\nThis creates a one-way connection between marty and einstein, where marty \"likes\" einstein.\n\nComplete documentation on the entity relationships API can be found here:\n\n<http://apigee.com/docs/usergrid/content/entity-relationships>\n\nThe following code shows you how to create this connection, and then verify that the connection has been made:\n\n\tmarty.connect('likes', dog, function (err, data) {\n\t\tif (err) {\n\t\t\t// error - connection not created\n\t\t} else {\n\n\t\t\t//call succeeded, so pull the connections back down\n\t\t\tmarty.getConnections('likes', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\t\t//error - could not get connections\n\t\t\t\t} else {\n\t\t\t\t\t//verify that connection exists\n\t\t\t\t\tif (marty.likes.ralphy) {\n\t\t\t\t\t\t//success - connection exists\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//error - connection does not exist\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\nYou can also remove connections, by using the disconnect method:\n\n\tmarty.disconnect('likes', dog, function (err, data) {\n\t\tif (err) {\n\t\t\t//error - connection not deleted\n\t\t} else {\n\n\t\t\t//call succeeded, so pull the connections back down\n\t\t\tmarty.getConnections('likes', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\t//error - error getting connections\n\t\t\t\t} else {\n\t\t\t\t\t//verify that connection exists\n\t\t\t\t\tif (marty.likes.einstein) {\n\t\t\t\t\t\t//error - connection still exists\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//success - connection deleted\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\n###To log a user in\nUp to this point, we have shown how you can use the client secret / client id combination to authenticate your calls against the API.  For a server-side Node.js app, this may be all you need.  However, if you do find that your app requires that you authenticate an individual user, you have several options.\n\nThe first is to use client-side authentication with Ajax.  If you want to opt for this method, take a look at our Javascript SDK.  The syntax for usage is the same as this Node.js module, so it will be easy to pick up:\n\n<https://github.com/apigee/usergrid-javascript-sdk>\n\nThe other method is to log the user in server-side. When you log a user in, the API will return an OAuth token for you to use for calls to the API on the user's behalf.  Once that token is returned, you can either make a new client just for the user, or change the auth method on the existing client.  These methods are described below:\n\n\n\tusername = 'marty';\n\tpassword = 'mysecurepassword';\n\tclient.login(username, password,\n\t\tfunction (err) {\n\t\t\tif (err) {\n\t\t\t\t//error - could not log user in\n\t\t\t} else {\n\t\t\t\t//success - user has been logged in\n\n\t\t\t\t//the login call will return an OAuth token, which is saved\n\t\t\t\t//in the client object for later use.  Access it this way:\n\t\t\t\tvar token = client.token;\n\n\t\t\t\t//then make a new client just for the app user, then use this\n\t\t\t\t//client to make calls against the API\n\t\t\t\tvar appUserClient = new usergrid.client({\n\t\t\t\t\torgName:'yourorgname',\n\t\t\t\t\tappName:'yourappname',\n\t\t\t\t\tauthType:usergrid.AUTH_APP_USER,\n\t\t\t\t\ttoken:token\n\t\t\t\t});\n\n\t\t\t\t//alternitavely, you can change the authtype of the client:\n\t\t\t\tclient.authType = usergrid.AUTH_APP_USER;\n\n\t\t\t\t//Then make calls against the API.  For example, you can\n\t\t\t\t//get the user entity this way:\n\t\t\t\tclient.getLoggedInUser(function(err, data, user) {\n\t\t\t\t\tif(err) {\n\t\t\t\t\t\t//error - could not get logged in user\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//success - got logged in user\n\n\t\t\t\t\t\t//you can then get info from the user entity object:\n\t\t\t\t\t\tvar username = user.get('username');\n\n\t\t\t\t\t\t//to log the user out, call the logout() method\n\t\t\t\t\t\tappUserClient.logout();\n\t\t\t\t\t\tclient.logout();\n\n\t\t\t\t\t\t//verify the logout worked\n\t\t\t\t\t\tif (client.isLoggedIn()) {\n\t\t\t\t\t\t\t//error - logout failed\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//success - user has been logged out\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//since we don't need to App User level calls anymore,\n\t\t\t\t\t\t//set the authtype back to client:\n\t\t\t\t\t\tclient.authType = usergrid.AUTH_CLIENT_ID;\n\n\t\t\t\t\t\trunner(step, marty);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\t\t}\n\t);\n\n\nTo recap, once a user has been logged in, and an OAuth token has been acquired, use one of the two methods to make calls to the API:\n\n1. Use the same client object and change auth types before each call\n\n2. Grab the token and make a new client object specifically for user calls.\n\nEither method will work.\n\n\n###To log a user out\nTo log the user out, call:\n\n\tclient.logout();\n\nOr, if you made a new client object specifically for the app user:\n\n\tappUserClient.logout();\n\nThis destroys the token and user object in the client object, effectively logging the user out.\n\n##Groups\nThis module provides an easy way to make new groups. They follow the same syntax as Entities\n\n##Making generic calls\nIf you find that you need to make calls to the API that fall outside of the scope of the Entity and Collection objects, you can use the following format to make any REST calls against the API:\n\n\tclient.request(options, callback);\n\nThis format allows you to make almost any call against the App Services (Usergrid) API. For example, to get a list of users:\n\n\tvar options = {\n\t\tmethod:'GET',\n\t\tendpoint:'users'\n\t};\n\tclient.request(options, function (err, data) {\n\t\tif (err) {\n\t\t\t//error - GET failed\n\t\t} else {\n\t\t\t//data will contain raw results from API call\n\t\t\t//success - GET worked\n\t\t}\n\t});\n\nOr, to create a new user:\n\n\tvar options = {\n\t\tmethod:'POST',\n\t\tendpoint:'users',\n\t\tbody:{ username:'fred', password:'secret' }\n\t};\n\tclient.request(options, function (err, data) {\n\t\tif (err) {\n\t\t\t//error - POST failed\n\t\t} else {\n\t\t\t//data will contain raw results from API call\n\t\t\t//success - POST worked\n\t\t}\n\t});\n\nOr, to update the new user:\n\n\tvar options = {\n\t\tmethod:'PUT',\n\t\tendpoint:'users/fred',\n\t\tbody:{ newkey:'newvalue' }\n\t};\n\tclient.request(options, function (err, data) {\n\t\tif (err) {\n\t\t\t//error - PUT failed\n\t\t} else {\n\t\t\t//data will contain raw results from API call\n\t\t\t//success - PUT worked\n\t\t}\n\t});\n\nOr to delete the new user:\n\n\tvar options = {\n\t\tmethod:'DELETE',\n\t\tendpoint:'users/fred'\n\t};\n\tclient.request(options, function (err, data) {\n\t\tif (err) {\n\t\t\t//error - DELETE failed\n\t\t} else {\n\t\t\t//data will contain raw results from API call\n\t\t\t//success - DELETE worked\n\t\t}\n\t});\n\nThe Options Object for the client.request fuction:\n\n* `method` - http method (GET, POST, PUT, or DELETE), defaults to GET\n* `qs` - object containing querystring values to be appended to the uri\n* `body` - object containing entity body for POST and PUT requests\n* `endpoint` - API endpoint, for example \"users/fred\"\n* `mQuery` - boolean, set to true if running management query, defaults to false\n* `buildCurl` - boolean, set to true if you want to see equivalent curl commands in console.log, defaults to false\n\nYou can make any call to the API using the format above.  However, in practice using the higher level Entity and Collection objects will make life easier as they take care of much of the heavy lifting.\n\n\n###cURL\n[cURL](http://curl.haxx.se/) is an excellent way to make calls directly against the API. As mentioned in the **Getting started** section of this guide, one of the parameters you can add to the new client options object is **buildCurl**:\n\n\tvar client = new Usergrid.Client({\n\t\torgName:'yourorgname',\n\t\tappName:'sandbox',\n\t\tlogging: true, //optional - turn on logging, off by default\n\t\tbuildCurl: true //optional - turn on curl commands, off by default\n\t});\n\nIf you set this parameter to true, the SDK will build equivalent curl commands and send them to the console.log window. To learn how to see the console log, see this page:\n\n<http://apigee.com/docs/usergrid/content/displaying-app-services-api-calls-curl-commands>\n\nMore information on cURL can be found here:\n\n<http://curl.haxx.se/>\n\n## Contributing\nWe welcome your enhancements!\n\nLike [Usergrid](https://github.com/apigee/usergrid-node-module), the Usergrid Javascript SDK is open source and licensed under the Apache License, Version 2.0.\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Added some feature'`)\n4. Push your changes to the upstream branch (`git push origin my-new-feature`)\n5. Create new Pull Request (make sure you describe what you did and why your mod is needed)\n\n##More information\nFor more information on Apigee App Services, visit <http://apigee.com/about/developers>.\n\n## Copyright\nCopyright 2013 Apigee Corporation\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n<http://www.apache.org/licenses/LICENSE-2.0>\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.",
  "readmeFilename": "readme.md",
  "homepage": "https://github.com/apigee/usergrid-node-module",
  "_id": "usergrid@0.10.7",
  "_from": "usergrid@0.10.7",
  "dist": {
    "shasum": "d0e50ed054e866b741096973fbd35f96dd9556d0"
  },
  "_resolved": "https://registry.npmjs.org/usergrid/-/usergrid-0.10.7.tgz"
}
